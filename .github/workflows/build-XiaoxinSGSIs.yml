name: build_XiaoxinSGSIs_Old_With_Ai-fix

on:
  watch:
    types: [started]

jobs:
  build:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id

    steps:
    - name: 检出代码库
      uses: actions/checkout@v3
      
    - name: 清理工作区
      run: |
        rm -rf SGSI-build-tool upload || true
        df -h
        
    - name: 读取配置文件
      id: var
      run: |
        # 从sgsi.json读取配置
        rom_url=$(jq -r '.rom_url' sgsi.json)
        rom_name=$(jq -r '.rom_name' sgsi.json)
        pack_sgsi=$(jq -r '.pack_sgsi' sgsi.json)
        make_miui=$(jq -r '.make_miui' sgsi.json)
        make_flyme=$(jq -r '.make_flyme' sgsi.json)
        make_coloros=$(jq -r '.make_coloros' sgsi.json)
        make_h2os=$(jq -r '.make_h2os' sgsi.json)
        make_smartisanos=$(jq -r '.make_smartisanos' sgsi.json)
        make_zui=$(jq -r '.make_zui' sgsi.json)
        make_super=$(jq -r '.make_super' sgsi.json)
        
        # 使用环境文件设置环境变量
        echo "rom_url=$rom_url" >> $GITHUB_ENV
        echo "rom_name=$rom_name" >> $GITHUB_ENV
        echo "pack_sgsi=$pack_sgsi" >> $GITHUB_ENV
        echo "make_miui=$make_miui" >> $GITHUB_ENV
        echo "make_flyme=$make_flyme" >> $GITHUB_ENV
        echo "make_coloros=$make_coloros" >> $GITHUB_ENV
        echo "make_h2os=$make_h2os" >> $GITHUB_ENV
        echo "make_smartisanos=$make_smartisanos" >> $GITHUB_ENV
        echo "make_zui=$make_zui" >> $GITHUB_ENV
        echo "make_super=$make_super" >> $GITHUB_ENV
        
    - name: 下载构建工具
      run: |
        # 使用原始GitHub链接下载
        tool_url="https://github.com/xiaoxindada/SGSI-build-tool/releases/download/v1.9/SGSI-build-tool.tar"
        
        # 下载并重试机制
        max_retries=5
        for i in $(seq 1 $max_retries); do
          echo "尝试下载构建工具 (第 $i 次)"
          if command -v curl &> /dev/null; then
            curl -fL -o SGSI-build-tool.tar "$tool_url" && break
          else
            wget -c -O SGSI-build-tool.tar "$tool_url" && break
          fi
          sleep 10
          echo "下载中断，继续尝试..."
        done
        
        # 如果原始链接失败，尝试备用源
        if [ ! -f SGSI-build-tool.tar ]; then
          echo "原始链接下载失败，尝试备用源..."
          alt_url="https://hub.yzuu.cf/xiaoxindada/SGSI-build-tool/releases/download/v1.9/SGSI-build-tool.tar"
          if command -v curl &> /dev/null; then
            curl -fL -o SGSI-build-tool.tar "$alt_url" || {
              echo "::error::工具包下载失败"
              exit 1
            }
          else
            wget -c -O SGSI-build-tool.tar "$alt_url" || {
              echo "::error::工具包下载失败"
              exit 1
            }
          fi
        fi
        
        echo "下载成功！文件大小: $(du -sh SGSI-build-tool.tar | cut -f1)"
        
    - name: 设置构建环境
      run: |
        tar -xf SGSI-build-tool.tar --no-same-owner --no-overwrite-dir
        
        if [ ! -d "SGSI-build-tool" ]; then
          echo "::error::未找到SGSI-build-tool目录"
          ls -la
          exit 1
        fi
        
        # 设置执行权限
        echo "设置脚本文件执行权限..."
        find SGSI-build-tool -type f \( -name "*.sh" -o -name "*.py" -o -name "perl" \) -exec chmod +x {} \;
        chmod +x SGSI-build-tool/10/bin/*
        chmod +x SGSI-build-tool/10/fixbug/*.sh
        
        # 特别确保关键文件有权限
        chmod +x SGSI-build-tool/10/make.sh
        chmod +x SGSI-build-tool/10/setup.sh
        chmod +x SGSI-build-tool/10/SGSI.sh
        
        # 移除所有脚本中的交互式read命令
        echo "移除交互式read命令..."
        find SGSI-build-tool -type f -name "*.sh" -exec sed -i '/read -p/d' {} \;
        find SGSI-build-tool -type f -name "*.sh" -exec sed -i 's/^\s*read\s.*//g' {} \;
        
        # 修复set-output弃用警告
        echo "更新弃用的set-output命令..."
        find SGSI-build-tool -type f -name "*.sh" -exec sed -i 's/echo "::set-output name=\(.*\)::\(.*\)"/echo "\1=\2" >> $GITHUB_OUTPUT/g' {} \;
        
        # 初始化环境
        cd SGSI-build-tool/10
        ./setup.sh || true
        cd ../..
        
        # 验证关键文件权限
        echo "验证权限:"
        ls -l SGSI-build-tool/10/make.sh
        ls -l SGSI-build-tool/10/bin/*
        
    - name: 磁盘空间监控
      run: |
        echo "::group::磁盘空间检查"
        df -h
        min_free=10 # 最小10GB空闲空间
        free_space=$(df -BG . | awk 'NR==2 {print $4}' | tr -d 'G')
        
        if [ "$free_space" -lt "$min_free" ]; then
          echo "::error::磁盘空间不足! 需要至少 ${min_free}GB, 当前只有 ${free_space}GB"
          exit 1
        fi
        echo "::endgroup::"
        
    - name: 下载ROM文件
      run: |
        mkdir -p SGSI-build-tool/10/tmp
        rom_path="SGSI-build-tool/10/tmp/${{ env.rom_name }}"
        
        # 带进度显示和重试的下载
        function download_with_progress() {
          if command -v curl &> /dev/null; then
            curl -# -L -k -C - "$1" -o "$2"
          else
            wget --progress=bar:force -c "$1" -O "$2"
          fi
        }
        
        max_retries=5
        for i in $(seq 1 $max_retries); do
          echo "下载ROM文件 (尝试 $i/$max_retries)"
          download_with_progress "${{ env.rom_url }}" "$rom_path" && break
          sleep 10
          echo "下载中断，继续尝试..."
        done

        if [ ! -f "$rom_path" ]; then
          echo "::error::ROM文件下载失败"
          exit 1
        fi
        
        # 校验最小文件大小
        min_size=$((100*1024*1024)) # 100MB
        file_size=$(stat -c%s "$rom_path")
        if [ $file_size -lt $min_size ]; then
          echo "::error::ROM文件过小 (${file_size}字节)，可能不完整"
          exit 1
        fi
    
    - name: 启用Super分区支持
      if: ${{ env.make_super == 'true' }}
      run: sed -i 's/SGSI.sh/dynamic_SGSI.sh/g' SGSI-build-tool/10/make.sh
    
    - name: 生成MIUI镜像
      if: ${{ env.make_miui == 'true' }}
      run: |
        rm -f SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/MIUI.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
        
    - name: 生成Flyme镜像
      if: ${{ env.make_flyme == 'true' }}
      run: |
        rm -f SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/Flyme.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
        
    - name: 生成ColorOS镜像
      if: ${{ env.make_coloros == 'true' }}
      run: |
        python3 SGSI-build-tool/10/oppo_ozip/ozipdecrypt.py SGSI-build-tool/10/tmp/${{ env.rom_name }}
        rm -f SGSI-build-tool/10/tmp/${{ env.rom_name }} SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/ColorOS.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
        
    - name: 生成HydrogenOS镜像
      if: ${{ env.make_h2os == 'true' }}
      run: |
        rm -f SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/H2OS.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
        
    - name: 生成SmartisanOS镜像
      if: ${{ env.make_smartisanos == 'true' }}
      run: |
        rm -f SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/SmartisanOS.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
        
    - name: 生成ZUI镜像
      if: ${{ env.make_zui == 'true' }}
      run: |
        rm -f SGSI-build-tool/10/fixbug/fixbug.sh
        mv fix/ZUI.sh SGSI-build-tool/10/fixbug/fixbug.sh
        chmod +x SGSI-build-tool/10/fixbug/fixbug.sh
         
    - name: 构建SGSI系统镜像
      timeout-minutes: 120
      run: |
        set -euo pipefail
        
        echo "::group::准备构建环境"
        # 确保所有脚本文件有执行权限
        find SGSI-build-tool/10 -name "*.sh" -exec chmod +x {} \;
        chmod +x SGSI-build-tool/10/bin/*
        chmod +x SGSI-build-tool/10/fixbug/*.sh
        
        # 特别确保make.sh有权限
        if [ ! -x "SGSI-build-tool/10/make.sh" ]; then
            echo "修复make.sh权限..."
            chmod +x SGSI-build-tool/10/make.sh
        fi
        
        # 移除权限相关命令
        find SGSI-build-tool/10 -type f -exec sed -i '/chown/d' {} \;
        
        # 准备构建文件
        rm -f SGSI-build-tool/10/{SGSI.sh,makeimg.sh,dynamic_SGSI.sh,oppo.sh}
        if [ -d "make" ] && [ -n "$(ls make)" ]; then
            mv make/* SGSI-build-tool/10/
        fi
        if [ -d "bin" ] && [ -n "$(ls bin)" ]; then
            mv bin/* SGSI-build-tool/10/bin/
        fi
        
        # 进入构建目录
        cd SGSI-build-tool/10
        
        # 移除交互式命令
        echo "再次移除交互式命令..."
        find . -type f -name "*.sh" -exec sed -i '/read -p/d' {} \;
        find . -type f -name "*.sh" -exec sed -i 's/^\s*read\s.*//g' {} \;
        
        # 修复set-output弃用警告
        echo "再次更新弃用的set-output命令..."
        find . -type f -name "*.sh" -exec sed -i 's/echo "::set-output name=\(.*\)::\(.*\)"/echo "\1=\2" >> $GITHUB_OUTPUT/g' {} \;
        
        # 创建输出目录结构
        mkdir -p out/{system,config}
        mkdir -p out/system/{bin,etc,lib,usr,framework,app,priv-app,vendor}
        
        # 创建默认配置文件
        echo -e "# 默认文件上下文\n/system(/.*)? u:object_r:system_file:s0\n/vendor(/.*)? u:object_r:vendor_file:s0" > out/config/system_file_contexts
        echo -e "# 默认文件系统配置\n/system 0 0 755\n/vendor 0 0 755" > out/config/system_fs_config
        
        # 关键文件校验
        required_files=(
          "make.sh"
          "bin/mke2fs"
          "bin/e2fsdroid"
          "bin/simg2img"
          "bin/img2simg"
          "fixbug/fixbug.sh"
        )
        
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "::error::关键文件缺失: $file"
            exit 1
          fi
          
          # 确保文件可执行
          if [[ "$file" == *.sh || "$file" == bin/* ]]; then
            if [ ! -x "$file" ]; then
              echo "修复 $file 权限..."
              chmod +x "$file"
            fi
          fi
        done
        
        # 校验ROM文件
        rom_path="tmp/${{ env.rom_name }}"
        if [ ! -f "$rom_path" ]; then
          echo "::error::ROM文件不存在: $rom_path"
          exit 1
        fi
        
        min_rom_size=$((100*1024*1024)) # 100MB
        rom_size=$(stat -c%s "$rom_path")
        if [ $rom_size -lt $min_rom_size ]; then
          echo "::error::ROM文件过小 (${rom_size}字节)，可能下载不完整"
          exit 1
        fi
        echo "::endgroup::"
        
        echo "::group::执行make.sh构建"
        # 验证make.sh权限
        if [ ! -x "make.sh" ]; then
            echo "::warning::make.sh缺少执行权限，尝试修复..."
            chmod +x make.sh
            if [ ! -x "make.sh" ]; then
                echo "::error::无法修复make.sh权限"
                exit 126
            fi
        fi
        
        # 设置资源限制
        ulimit -v $((4096 * 1024))  # 限制内存使用
        ionice -c 3 -p $$           # 降低IO优先级
        
        # 执行构建
        build_log="build_${GITHUB_RUN_ID}.log"
        
        # 使用script命令确保实时输出
        if command -v script >/dev/null; then
          script -q -c "./make.sh" "$build_log"
        else
          ./make.sh 2>&1 | tee "$build_log"
        fi
        
        build_exit=$?
        if [ $build_exit -ne 0 ]; then
          echo "::error::make.sh构建失败，退出码: $build_exit"
          # 提取日志中的关键错误
          grep -i -E "error|fail|critical|exception" "$build_log" || true
          exit $build_exit
        fi
        
        # 检查特定错误模式
        if grep -q "sdat2img: failed" "$build_log"; then
          echo "::error::sdat2img转换失败"
          exit 1
        fi
        echo "::endgroup::"
        
        echo "::group::校验构建结果"
        # 检查生成的镜像文件
        if [ ! -f "out/system.img" ]; then
          echo "::warning::system.img未生成，尝试手动创建"
          
          if [ ! -d "out/system" ]; then
            echo "::error::out/system目录不存在，无法创建镜像"
            exit 1
          fi
          
          # 计算镜像大小
          size_kb=$(du -sk out/system/ | cut -f1)
          img_size_kb=$((size_kb * 130 / 100))  # +30%
          img_size_mb=$((img_size_kb / 1024))
          [ $img_size_mb -lt 512 ] && img_size_mb=512
          
          echo "创建 ${img_size_mb}MB 镜像"
          ./bin/mke2fs -t ext4 -L /system -b 4096 -m 0 out/system.img ${img_size_mb}M
          ./bin/e2fsdroid -e -T 1230768000 -C out/config/system_fs_config -S out/config/system_file_contexts -f out/system/ -a /system out/system.img
        fi
        
        # 校验生成的镜像
        if [ ! -f "out/system.img" ]; then
          echo "::error::最终system.img不存在"
          exit 1
        fi
        
        min_img_size=$((300*1024*1024)) # 300MB
        img_size=$(stat -c%s "out/system.img")
        if [ $img_size -lt $min_img_size ]; then
          echo "::error::生成的system.img过小 (${img_size}字节)，可能构建失败"
          exit 1
        fi
        
        # 移动生成的文件
        mkdir -p SGSI
        mv out/system.img SGSI/
        echo "构建产物大小: $(du -sh SGSI/system.img)"
        echo "::endgroup::"
        
        cd ../..
        
    # 检查构建输出文件
    - name: 检查构建输出文件
      run: |
        echo "::group::构建输出检查"
        cd SGSI-build-tool/10/SGSI
        
        # 列出输出目录内容
        echo "构建输出内容:"
        ls -lh
        
        # 检查实际生成的文件
        output_file=$(ls -1)
        if [ -z "$output_file" ]; then
          echo "::error::未生成任何构建输出文件"
          exit 1
        fi
        
        # 如果只有一个文件，则将其作为主镜像文件
        if [ $(ls | wc -l) -eq 1 ]; then
          main_file=$output_file
          file_type=$(file -b "$main_file")
          echo "检测到输出文件: $main_file, 类型: $file_type"
          
          # 处理压缩包
          if echo "$file_type" | grep -q 'archive\|compressed'; then
            echo "检测到压缩文件, 尝试解压..."
            case "$file_type" in
              *Zip*|*ZIP*)
                unzip "$main_file"
                rm "$main_file"
                ;;
              *gzip*|*GZIP*)
                mv "$main_file" "$main_file.gz"
                gzip -d "$main_file.gz"
                ;;
              *XZ*)
                mv "$main_file" "$main_file.xz"
                xz -d "$main_file.xz"
                ;;
              *)
                echo "::error::未知压缩格式: $file_type"
                exit 1
                ;;
            esac
            # 重新检查解压后的文件
            main_file=$(ls -1 | head -1)
          fi
          
          # 处理稀疏镜像
          if file -b "$main_file" | grep -q 'Android sparse image'; then
            echo "检测到Android稀疏镜像, 转换为原始镜像..."
            mv "$main_file" "${main_file}.sparse"
            ./../../bin/simg2img "${main_file}.sparse" "$main_file"
            if [ $? -ne 0 ]; then
              echo "::error::稀疏镜像转换失败"
              exit 1
            fi
            rm "${main_file}.sparse"
          fi
          
          # 重命名为标准名称
          if [ "$main_file" != "system [ "$main_file" != "system.img" ]; then
            mv "$main_file" system.img
          fi
        else
          # 如果多个文件，尝试寻找system.img
          if [ -f "system.img" ]; then
            echo "已找到system.img文件"
          else
            echo "::error::输出目录包含多个文件但未找到system.img"
            ls -lh
            exit 1
          fi
        fi
        
        # 最终验证system.img
        if [ ! -f "system.img" ]; then
          echo "::error::system.img不存在"
          exit 1
        fi
        
        # 验证镜像格式
        img_type=$(file -b system.img)
        echo "镜像最终类型: $img_type"
        
        # 检查文件系统类型
        if ! echo "$img_type" | grep -qE 'ext4 filesystem|Linux rev 1.0 ext4 filesystem'; then
          echo "::warning::镜像格式不符合预期"
          
          # 尝试挂载验证
          mkdir -p mount_test
          if sudo mount -o ro,loop system.img mount_test 2>/dev/null; then
            echo "镜像挂载成功, 验证通过"
            sudo umount mount_test
          else
            echo "::error::镜像格式验证失败，无法挂载"
            exit 1
          fi
        fi
        
        echo "镜像验证通过"
        echo "::endgroup::"
        
    # 新增步骤：压缩system.img
    - name: 压缩系统镜像
      run: |
        echo "::group::压缩system.img"
        cd SGSI-build-tool/10/SGSI
        
        # 记录原始大小
        original_size=$(du -sh system.img | cut -f1)
        echo "原始大小: $original_size"
        
        # 使用gzip进行压缩（保留原始文件的时间戳）
        echo "开始压缩..."
        gzip -9 -k -v system.img
        
        if [ ! -f "system.img.gz" ]; then
          echo "::error::压缩失败，未生成system.img.gz"
          exit 1
        fi
        
        # 记录压缩后大小
        compressed_size=$(du -sh system.img.gz | cut -f1)
        echo "压缩后大小: $compressed_size"
        
        # 计算压缩率
        original_bytes=$(stat -c%s "system.img")
        compressed_bytes=$(stat -c%s "system.img.gz")
        compression_rate=$(echo "scale=2; (1 - $compressed_bytes/$original_bytes)*100" | bc)
        echo "压缩率: ${compression_rate}%"
        
        # 删除原始镜像（保留压缩版本）
        rm -f system.img
        
        echo "压缩完成"
        echo "::endgroup::"
        
    - name: 打包系统补丁
      run: |
        for i in 1 2 3; do
          if [ -d "Patch/Patch$i" ]; then
            echo "打包补丁 Patch$i"
            zip -r -0 "Patch$i.zip" "Patch/Patch$i"/*
            mkdir -p SGSI-build-tool/10/SGSI
            mv "Patch$i.zip" SGSI-build-tool/10/SGSI/
          fi
        done

    - name: 创建最终包
      run: |
        echo "::group::创建最终包"
        # 确保SGSI目录存在
        mkdir -p SGSI-build-tool/10/SGSI
        
        # 创建压缩包
        pack_name="${{ env.pack_sgsi }}"
        echo "创建压缩包: $pack_name"
        
        # 直接在工作区根目录创建压缩包
        zip -r -0 "$pack_name" SGSI-build-tool/10/SGSI/*
        
        # 生成SHA256校验文件
        sha256sum "$pack_name" > "${pack_name}.sha256"
        
        # 检查压缩包
        if [ ! -f "$pack_name" ]; then
          echo "::error::压缩包创建失败: $pack_name"
          exit 1
        fi
        
        echo "压缩包大小: $(du -sh "$pack_name" | cut -f1)"
        echo "::endgroup::"
        
    - name: 准备上传文件
      run: |
        echo "::group::准备上传文件"
        pack_name="${{ env.pack_sgsi }}"
        
        # 创建上传目录
        mkdir -p upload
        mv "$pack_name" upload/
        mv "${pack_name}.sha256" upload/
        
        # 添加恢复说明
        cat <<EOF > upload/RECOVERY_INSTRUCTIONS.txt
        # 文件恢复说明
        
        ## 文件完整性校验:
        sha256sum -c ${pack_name}.sha256
        
        ## 如果文件被分割：
        1. 合并所有部分: cat ${pack_name}_part* > $pack_name
        2. 验证完整性: sha256sum -c ${pack_name}.sha256
        
        ## 镜像恢复：
        1. 解压ZIP包
        2. 解压镜像: gunzip system.img.gz
        3. 刷入镜像: fastboot flash system system.img
        EOF
        
        # 检查文件大小
        file_size=$(stat -c%s "upload/$pack_name")
        max_size=1600000000  # 1.6GB (新的上传限制)
        
        echo "压缩包大小: $(numfmt --to=iec $file_size)"
        
        if [ $file_size -gt $max_size ]; then
          echo "文件超过1.6GB，进行分割..."
          
          # 计算分割大小 (1.5GB)
          split_size=1500m
          
          # 分割文件
          cd upload
          split -b $split_size -d "$pack_name" "${pack_name}_part"
          rm "$pack_name"  # 删除原始文件，保留分割后的部分
          
          echo "分割完成，上传目录内容:"
          ls -lh
        else
          echo "上传目录内容:"
          ls -lh upload/
        fi
        echo "::endgroup::"
        
    - name: 验证上传文件
      run: |
        echo "::group::验证上传文件"
        if [ -z "$(ls -A upload)" ]; then
          echo "::error::上传目录为空!"
          exit 1
        else
          echo "上传文件列表 ($(ls upload | wc -l) 个文件):"
          ls -lh upload
          
          # 尝试验证校验文件（如果未分割）
          if [ ! -f "upload/${pack_name}_part00" ] && [ -f "upload/${pack_name}.sha256" ]; then
            echo "尝试校验文件完整性..."
            (cd upload && sha256sum -c "${pack_name}.sha256") || {
              echo "::warning::文件校验失败，但继续执行"
            }
          fi
        fi
        echo "::endgroup::"
        
    - name: 发送通知
      if: always()
      run: |
        if [ "${{ job.status }}" == 'success' ]; then
          echo "::notice::构建成功! 版本号: ${{ github.run_number }}"
        else
          echo "::error::构建失败! 详情查看工作流运行"
        fi
          
    - name: 发布SGSI版本
      uses: ncipollo/release-action@v1.8.6
      with:
        artifacts: 'upload/*'
        name: xiaoxinSGSI-ab-Android10-unpack
        tag: xiaoxinSGSI-ab-Android10-${{ github.run_number }}
        token: ${{ secrets.GITHUB_TOKEN }}
