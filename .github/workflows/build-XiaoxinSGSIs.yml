name: build_XiaoxinSGSIs

on:
  watch:
    types: [started]

jobs:
  build:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id

    steps:
    - name: 初始化环境
      run: |
        rm -rf SGSI-build-tool upload tmp_fix || true
        mkdir -p tmp_fix
        df -h
        
    - name: 检出代码库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: 验证配置文件存在
      id: config_check
      run: |
        echo "📁 当前目录内容:"
        ls -la
        
        if [ ! -f sgsi.json ]; then
          echo "::error::❌ sgsi.json 配置文件不存在"
          echo "请在仓库根目录创建sgsi.json文件并填写配置"
          exit 1
        fi
        
        # 验证JSON格式
        if ! jq empty sgsi.json; then
          echo "::error::❌ sgsi.json 格式无效"
          echo "请检查JSON语法是否正确"
          exit 1
        fi
        
        # 创建配置文件备份
        cp sgsi.json config_backup.json
        echo "✅ 配置文件验证通过"
    
    - name: 安装依赖工具
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        
        # 验证jq安装
        if ! command -v jq &> /dev/null; then
          echo "::error::❌ jq 未安装成功"
          exit 1
        fi
        echo "✅ jq 版本: $(jq --version)"
    
    - name: 读取配置文件
      id: config
      run: |
        # 确保备份文件存在
        if [ ! -f "config_backup.json" ]; then
          echo "::error::❌ 配置文件备份不存在"
          echo "请检查上一步是否成功创建 config_backup.json"
          exit 1
        fi
        
        # 读取关键字段
        rom_url=$(jq -r '.rom_url' config_backup.json)
        rom_name=$(jq -r '.rom_name' config_backup.json)
        pack_sgsi=$(jq -r '.pack_sgsi' config_backup.json)
        upload_artifact=$(jq -r '.upload_artifact' config_backup.json)
        upload_wetransfer=$(jq -r '.upload_wetransfer' config_backup.json)
        
        # 设置默认值
        [ "$upload_artifact" == "null" ] && upload_artifact=true
        [ "$upload_wetransfer" == "null" ] && upload_wetransfer=false
        
        # 检查必需字段
        if [ -z "$rom_url" ] || [ "$rom_url" == "null" ]; then
          echo "::error::❌ rom_url 未定义"
          echo "请在sgsi.json中提供rom_url"
          exit 1
        fi
        
        # 如果rom_name为空，则从URL中提取文件名
        if [ -z "$rom_name" ] || [ "$rom_name" == "null" ]; then
          rom_name=$(basename "$rom_url")
          echo "ℹ️ 从URL提取ROM文件名: $rom_name"
        fi
        
        # 处理ROM类型
        rom_types=(miui flyme coloros h2os smartisanos zui)
        type_count=0
        current_type=""
        
        echo "🔍 检查ROM类型配置:"
        for type in "${rom_types[@]}"; do
          value=$(jq -r ".make_$type" config_backup.json 2>/dev/null || echo "false")
          
          # 处理null值
          [ "$value" == "null" ] && value="false"
          
          echo "  make_$type = $value"
          
          if [ "$value" == "true" ]; then
            ((type_count++))
            current_type=$type
          fi
        done
        
        if [ $type_count -gt 1 ]; then
          echo "::error::❌ 只能启用一个ROM类型"
          echo "请检查sgsi.json配置，只能有一个make_*设为true"
          exit 1
        fi
        
        # 输出环境变量
        echo "rom_url=$rom_url" >> $GITHUB_ENV
        echo "rom_name=$rom_name" >> $GITHUB_ENV
        echo "pack_sgsi=$pack_sgsi" >> $GITHUB_ENV
        echo "rom_type=${current_type:-none}" >> $GITHUB_ENV
        echo "upload_artifact=$upload_artifact" >> $GITHUB_ENV
        echo "upload_wetransfer=$upload_wetransfer" >> $GITHUB_ENV
        
        # 复制修复脚本
        if [ -n "$current_type" ]; then
          # 大小写兼容处理
          uppercase_type="${current_type^}"
          lowercase_type="${current_type}"
          
          script_path=""
          
          # 优先尝试大写文件名
          if [ -f "fix/${uppercase_type}.sh" ]; then
            script_path="fix/${uppercase_type}.sh"
          elif [ -f "fix/${lowercase_type}.sh" ]; then
            script_path="fix/${lowercase_type}.sh"
          fi
          
          if [ -n "$script_path" ]; then
            cp "$script_path" tmp_fix/fixbug.sh
            echo "✅ 使用修复脚本: $script_path"
          else
            echo "::warning::⚠️ 未找到 ${current_type} 修复脚本"
            # 创建空修复脚本防止后续步骤失败
            touch tmp_fix/fixbug.sh
          fi
        else
          echo "ℹ️ 未启用ROM类型，跳过修复脚本复制"
        fi
        
        # 显示读取的配置摘要
        echo "✅ 配置读取成功:"
        echo "  ROM URL: $rom_url"
        echo "  ROM名称: $rom_name"
        echo "  ROM类型: ${current_type:-无}"
        echo "  打包名称: $pack_sgsi"
        echo "  Artifact上传: $upload_artifact"
        echo "  WeTransfer上传: $upload_wetransfer"
    
    - name: 下载构建工具
      timeout-minutes: 5
      run: |
        tool_url="https://github.com/xiaoxindada/SGSI-build-tool/releases/download/v1.9/SGSI-build-tool.tar"
        attempts=0
        max_attempts=3
        
        while [ $attempts -lt $max_attempts ]; do
          ((attempts++))
          echo "尝试 #$attempts 下载构建工具..."
          
          if curl -L --fail --retry 3 -o SGSI-build-tool.tar "$tool_url"; then
            echo "✅ 下载成功"
            break
          elif wget -c -O SGSI-build-tool.tar "$tool_url"; then
            echo "✅ 下载成功"
            break
          else
            echo "❌ 下载失败，等待10秒后重试..."
            sleep 10
          fi
        done
        
        if [ ! -f SGSI-build-tool.tar ]; then
          echo "::error::❌ 工具包下载失败"
          exit 1
        fi
        
        if ! tar -tf SGSI-build-tool.tar >/dev/null; then
          echo "::error::❌ 工具包损坏"
          exit 1
        fi
        
        echo "🛠️ 工具包验证通过"
    
    - name: 设置构建环境
      run: |
        tar -xf SGSI-build-tool.tar
        chmod -R +x SGSI-build-tool
        
        cd SGSI-build-tool/10
        ./setup.sh || echo "⚠️ 忽略非关键错误"
        cd ../..
        
        echo "🛠️ 构建环境已设置"
    
    - name: 下载ROM文件
      timeout-minutes: 30
      run: |
        rom_path="SGSI-build-tool/10/tmp/${{ env.rom_name }}"
        echo "⬇️ 下载ROM: ${{ env.rom_url }}"
        
        # 确保目录存在
        mkdir -p "$(dirname "$rom_path")"
        
        # 使用最佳下载工具
        if command -v aria2c &>/dev/null; then
          echo "使用 aria2c 下载"
          aria2c -x8 -s8 -k1M --retry-wait=30 "${{ env.rom_url }}" -d "$(dirname "$rom_path")" -o "$(basename "$rom_path")"
        else
          echo "使用 curl 下载"
          curl -L -C - --retry 30 --retry-delay 30 "${{ env.rom_url }}" -o "$rom_path"
        fi
        
        # 验证文件大小
        min_size=$((100*1024*1024))  # 100MB
        file_size=$(stat -c%s "$rom_path" 2>/dev/null || echo 0)
        
        if [ $file_size -lt $min_size ]; then
          echo "::error::❌ ROM文件异常 (大小: $((file_size/1024/1024))MB)"
          exit 1
        fi
        
        echo "✅ 下载完成，大小: $((file_size/1024/1024))MB"
    
    - name: 处理ROM类型
      if: ${{ env.rom_type != 'none' }}
      run: |
        cd SGSI-build-tool/10
        
        case "${{ env.rom_type }}" in
          coloros)
            echo "🔓 解密ColorOS ROM..."
            python3 oppo_ozip/ozipdecrypt.py "tmp/${{ env.rom_name }}"
            decrypted_file="${rom_name%.*}.img"
            if [ -f "tmp/$decrypted_file" ]; then
              rm -f "tmp/${{ env.rom_name }}"
              echo "✅ 解密成功: $decrypted_file"
              echo "rom_name=$decrypted_file" >> $GITHUB_ENV
            else
              echo "::error::❌ ColorOS解密失败"
              exit 1
            fi
            ;;
          *)
            echo "ℹ️ ROM类型: ${{ env.rom_type }}，无需特殊处理"
            ;;
        esac
        
        # 应用修复脚本
        if [ -f "fixbug/fixbug.sh" ]; then
          chmod +x fixbug/fixbug.sh
          echo "🛠️ 已应用 ${{ env.rom_type }} 修复脚本"
        elif [ -n "${{ env.rom_type }}" ]; then
          echo "::warning::⚠️ 未找到 ${{ env.rom_type }} 修复脚本"
        fi
        
        # 处理Super分区支持
        if [ "$(jq -r '.make_super' ../sgsi.json)" == "true" ]; then
          sed -i 's/SGSI.sh/dynamic_SGSI.sh/g' make.sh
          echo "🛠️ 启用Super分区支持"
        fi
    
    - name: 构建系统镜像
      timeout-minutes: 120
      run: |
        cd SGSI-build-tool/10
        
        # 复制自定义文件
        if [ -d "../../make" ]; then
          cp -f ../../make/* ./
          echo "📂 已添加自定义make文件"
        fi
        if [ -d "../../bin" ]; then
          cp -f ../../bin/* bin/
          echo "📂 已添加自定义bin文件"
        fi
        
        # 确保脚本可执行
        find . -name "*.sh" -exec chmod +x {} \;
        chmod +x bin/*
        
        echo "::group::📜 构建日志"
        ./make.sh || build_failed=true
        echo "::endgroup::"
        
        if [ "$build_failed" = true ]; then
          echo "⚠️ 构建失败，尝试手动创建镜像..."
          if [ -d "out/system" ]; then
            size_kb=$(du -sk out/system/ | cut -f1)
            img_size_kb=$((size_kb * 130 / 100))
            img_size_mb=$((img_size_kb / 1024))
            [ $img_size_mb -lt 512 ] && img_size_mb=512
            
            ./bin/make_ext4fs -T 0 -S out/config/system_file_contexts \
                              -C out/config/system_fs_config \
                              -l ${img_size_mb}M -a system out/system.img out/system/
            
            if [ -f "out/system.img" ]; then
              mkdir -p SGSI
              mv out/system.img SGSI/
              echo "✅ 手动创建镜像成功"
            else
              echo "::error::❌ 无法手动创建镜像"
              exit 1
            fi
          else
            echo "::error::❌ 构建失败且无可用系统文件"
            exit 1
          fi
        else
          echo "✅ 构建成功"
        fi
        
        # 整理输出文件
        mkdir -p ../final_out
        mv SGSI/* ../final_out/ 2>/dev/null || true
        mv out/*.img ../final_out/ 2>/dev/null || true
        
        if [ -f "../final_out/system.img" ]; then
          orig_size=$(du -h "../final_out/system.img" | cut -f1)
          echo "原始大小: $orig_size" >> ../final_out/build_info.txt
        fi
        
        echo "📁 输出文件列表:"
        ls -l ../final_out/
    
    - name: 打包补丁
      if: ${{ success() }}
      run: |
        if [ -d "Patch" ]; then
          cd Patch
          for dir in */; do
            if [ -d "$dir" ]; then
              dir_name="${dir%/}"
              echo "📦 打包补丁: $dir_name"
              zip -r -0 "../../SGSI-build-tool/final_out/${dir_name}.zip" "$dir_name"
            fi
          done
          cd ..
        else
          echo "ℹ️ 未找到Patch目录，跳过补丁打包"
        fi
    
    - name: 压缩系统镜像
      if: ${{ success() }}
      run: |
        cd SGSI-build-tool/final_out
        
        if [ -f "system.img" ]; then
          echo "📦 开始压缩system.img..."
          original_size=$(du -h system.img | cut -f1)
          
          if ! command -v pigz &>/dev/null; then
            echo "🛠️ 安装pigz以获得更快压缩速度..."
            sudo apt-get update -qq
            sudo apt-get install -y pigz
          fi
          
          echo "⚙️ 使用pigz进行多线程压缩..."
          pigz -k -f -9 system.img
          
          compressed_size=$(du -h system.img.gz | cut -f1)
          echo "压缩后大小: $compressed_size" >> build_info.txt
          
          orig_bytes=$(stat -c%s system.img)
          comp_bytes=$(stat -c%s system.img.gz)
          ratio=$(echo "scale=2; (1 - $comp_bytes/$orig_bytes) * 100" | bc)
          echo "压缩率: $ratio%" >> build_info.txt
          
          echo "✅ 压缩完成: ${original_size} → ${compressed_size} (节省 ${ratio}%)"
          ls -lh system.img*
        else
          echo "ℹ️ 未找到system.img，跳过压缩"
        fi
    
    - name: 创建发布包
      if: ${{ success() }}
      run: |
        cd SGSI-build-tool/final_out
        
        if [ -z "$(ls -A .)" ]; then
          echo "::error::❌ 无可用输出文件"
          exit 1
        fi
        
        pack_name="${{ env.pack_sgsi }}"
        
        # 显示构建信息
        if [ -f "build_info.txt" ]; then
          echo "::group::📊 镜像压缩信息"
          cat build_info.txt
          echo "::endgroup::"
          
          orig_size=$(grep "原始大小" build_info.txt | cut -d: -f2 | xargs)
          comp_size=$(grep "压缩后大小" build_info.txt | cut -d: -f2 | xargs)
          ratio=$(grep "压缩率" build_info.txt | cut -d: -f2 | xargs)
          
          if [ -n "$orig_size" ] && [ -n "$comp_size" ]; then
            echo "✅ 压缩结果: ${orig_size} → ${comp_size} (节省 $ratio)"
          fi
        fi
        
        # 打包文件
        echo "📦 创建发布包: $pack_name"
        zip -r -0 "../$pack_name" .
        
        # 处理大文件分割
        cd ..
        file_size=$(stat -c%s "$pack_name")
        max_size=1400000000  # 1.4GB
        
        if [ $file_size -gt $max_size ]; then
          echo "✂️ 分割大文件 (大小: $((file_size/1024/1024))MB)"
          split -b 1000M -d "$pack_name" "${pack_name}_part"
          rm "$pack_name"
        else
          echo "ℹ️ 文件大小: $((file_size/1024/1024))MB，无需分割"
        fi
        
        # 准备上传
        mkdir -p ../upload
        mv "${pack_name}"* ../upload/ || true
        
        # 设置上传文件路径
        output_file=$(ls $PWD/../upload/$pack_name* | head -n1)
        if [ -n "$output_file" ]; then
          echo "📎 上传文件: $(basename "$output_file")"
          echo "OUTPUT_FILE=$output_file" >> $GITHUB_ENV
        else
          echo "::error::❌ 未找到输出文件"
          exit 1
        fi
    
    - name: 发布GitHub版本
      uses: softprops/action-gh-release@v1
      with:
        files: upload/*
        tag_name: build-${{ github.run_number }}
        generate_release_notes: true
        body: |
          构建 #${{ github.run_number }} 已完成！
          查看构建日志获取镜像压缩详情
          
          ${{ env.upload_wetransfer == 'true' && '>  ️ **重要提示**：本构建包含WeTransfer下载链接（有效期7天），请在作业摘要中查看详情！' || '' }}
    
    - name: 上传构建产物
      if: ${{ env.upload_artifact == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: SGSI-build-output
        path: upload/*
        retention-days: 7
        
    - name: 上传到WeTransfer
      if: ${{ env.upload_wetransfer == 'true' }}
      run: |
        echo "☁️ 上传到WeTransfer..."
        cd $GITHUB_WORKSPACE
        
        # 检查文件是否存在
        if [ ! -f "$OUTPUT_FILE" ]; then
          echo "::error::❌ 要上传的文件不存在: $OUTPUT_FILE"
          exit 1
        fi
        
        # 下载文件传输工具
        echo "🛠️ 安装 file-transfer 工具..."
        curl -sL https://git.io/file-transfer | sh
        
        # 获取文件大小信息
        FILE_SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)
        echo "⬆️ 开始上传文件: $(basename "$OUTPUT_FILE") (大小: $FILE_SIZE)..."
        
        # 计算到期日期
        EXPIRY_DATE=$(date -d "+7 days" "+%Y-%m-%d")
        
        # 上传并获取结果
        TRANSFER_OUTPUT=$(./transfer wet "$OUTPUT_FILE")
        echo "$TRANSFER_OUTPUT"
        
        # 提取下载链接
        DOWNLOAD_LINK=$(echo "$TRANSFER_OUTPUT" | grep -o 'https://we.tl/[^ ]*' | head -n1)
        if [ -n "$DOWNLOAD_LINK" ]; then
          # 添加到工作流摘要（带有效期声明）
          echo "##   WeTransfer 下载地址" >> $GITHUB_STEP_SUMMARY
          echo ">   **链接有效期至 ${EXPIRY_DATE}**" >> $GITHUB_STEP_SUMMARY
          echo "[点击下载]($DOWNLOAD_LINK)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "文件: $(basename "$OUTPUT_FILE")" >> $GITHUB_STEP_SUMMARY
          echo "大小: $FILE_SIZE" >> $GITHUB_STEP_SUMMARY
          
          # 添加到控制台输出
          echo "✅ WeTransfer上传成功！"
          echo "📥 下载链接: $DOWNLOAD_LINK"
          echo "⏳ 链接有效期至: ${EXPIRY_DATE}"
          
          # 设置环境变量供后续步骤使用
          echo "DOWNLOAD_LINK=$DOWNLOAD_LINK" >> $GITHUB_ENV
          echo "EXPIRY_DATE=$EXPIRY_DATE" >> $GITHUB_ENV
        else
          echo "::warning::⚠️ 未找到下载链接"
          echo "完整输出: $TRANSFER_OUTPUT" # 输出完整结果用于调试
        fi
    
    - name: 显示最终摘要
      if: always()
      run: |
        echo "✅ 构建流程已完成"
        echo "::group::📊 构建摘要"
        echo "ROM URL: ${{ env.rom_url }}"
        echo "ROM名称: ${{ env.rom_name }}"
        echo "ROM类型: ${{ env.rom_type }}"
        echo "构建编号: ${{ github.run_number }}"
        
        # 镜像压缩信息
        if [ -f "SGSI-build-tool/final_out/build_info.txt" ]; then
          orig_size=$(grep "原始大小" SGSI-build-tool/final_out/build_info.txt | cut -d: -f2 | xargs)
          comp_size=$(grep "压缩后大小" SGSI-build-tool/final_out/build_info.txt | cut -d: -f2 | xargs)
          ratio=$(grep "压缩率" SGSI-build-tool/final_out/build_info.txt | cut -d: -f2 | xargs)
          
          if [ -n "$orig_size" ] && [ -n "$comp_size" ]; then
            echo "✨ 镜像大小对比: ${orig_size} → ${comp_size} (节省 ${ratio})"
          fi
        fi
        
        # WeTransfer链接信息
        if [[ -n "$DOWNLOAD_LINK" && -n "$EXPIRY_DATE" ]]; then
          echo ""
          echo "🌐 WeTransfer下载链接: $DOWNLOAD_LINK"
          echo "⏳ 链接有效期至: $EXPIRY_DATE"
        fi
        
        echo "::endgroup::"
