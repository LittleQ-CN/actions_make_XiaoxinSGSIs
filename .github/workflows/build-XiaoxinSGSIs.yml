name: build_XiaoxinSGSIs

on:
  watch:
    types: [started]

env:
  BUILD_TOOL_VERSION: "v1.9"
  BUILD_TOOL_URL: "https://github.com/xiaoxindada/SGSI-build-tool/releases/download/$BUILD_TOOL_VERSION/SGSI-build-tool.tar"
  BUILD_DIR: "SGSI-build-tool/10"
  ROM_DIR: "${{ env.BUILD_DIR }}/tmp"

jobs:
  build:
    runs-on: ubuntu-22.04
    if: github.event.repository.owner.id == github.event.sender.id
    timeout-minutes: 180

    steps:
    - name: 检出代码库
      uses: actions/checkout@v3
      
    - name: 清理工作区
      run: |
        rm -rf SGSI-build-tool upload out || true
        df -h
        
    - name: 读取配置文件
      id: config
      run: |
        if [ ! -f "sgsi.json" ]; then
          echo "::error::配置文件 sgsi.json 不存在!"
          exit 1
        fi
        
        declare -A config
        config[rom_url]=$(jq -r '.rom_url' sgsi.json)
        config[rom_name]=$(jq -r '.rom_name' sgsi.json)
        config[pack_sgsi]=$(jq -r '.pack_sgsi' sgsi.json)
        config[make_miui]=$(jq -r '.make_miui' sgsi.json)
        config[make_flyme]=$(jq -r '.make_flyme' sgsi.json)
        config[make_coloros]=$(jq -r '.make_coloros' sg极速下载.json)
        config[make_h2os]=$(jq -r '.make_h2os' sgsi.json)
        config[make_smartisanos]=$(jq -r '.make_smartisanos' sgsi.json)
        config[make_zui]=$(jq -r '.make_zui' sgsi.json)
        config[make_super]=$(jq -r '.make_super' sgsi.json)
        
        if [ -z "${config[rom_url]}" ] || [ -z "${config[rom_name]}" ]; then
          echo "::error::ROM URL或名称为空!"
          exit 1
        fi
        
        {
          echo "rom_url=${config[rom_url]}"
          echo "rom_name=${config[rom_name]}"
          echo "pack_sgsi=${config[pack_sgsi]}"
          echo "make_miui=${config[make_miui]}"
          echo "make_flyme=${config[make_flyme]}"
          echo "make_coloros=${config[make_coloros]}"
          echo "make_h2os=${config[make_h2os]}"
          echo "make_smartisanos=${config[make_smartisanos]}"
          echo "make_zui=${config[make_zui]}"
          echo "make_super=${config[make_super]}"
        } >> $GITHUB_OUTPUT
        
    - name: 安装下载工具
      run: |
        echo "安装下载工具..."
        sudo apt-get update -qq
        sudo apt-get install -y -qq axel pv jq bc
        echo "axel版本: $(axel --version | head -1)"
        echo "pv版本: $(pv --version | head -1)"
        echo "jq版本: $(jq --version)"
        
    - name: 下载构建工具
      run: |
        if command -v curl &> /dev/null; then
          curl -L -k --retry 3 --retry-delay 5 -sS -o SGSI-build-tool.tar "$BUILD_TOOL_URL" || curl_fail=$?
        else
          wget -q -c --tries=3 "$BUILD_TOOL_URL" || wget_fail=$?
        fi
        
        if [ ! -f "SGSI-build-tool.tar" ]; then
          echo "::error::工具包下载失败"
          echo "curl状态: ${curl_fail:-未使用}, wget状态: ${wget_fail:-未使用}"
          exit 1
        fi
        
        echo "工具包大小: $(du -sh SGSI-build-tool.tar | cut -f1)"
        
    - name: 设置构建环境
      run: |
        if ! tar -xf SGSI-build-tool.tar --no-same-owner --no-overwrite-dir; then
          echo "::error::解压构建工具失败"
          exit 1
        fi
        
        if [ ! -d "SGSI-build-tool" ]; then
          echo "::error::解压后未找到SGSI-build-tool目录"
          ls -la
          exit 1
        fi
        
        find SGSI-build-tool -type f -exec grep -lZ 'chown\|sudo' {} + | xargs -0 sed -i '/chown\|sudo/d'
        find SGSI-build-tool -type f -name "*.sh" -exec chmod +x {} \;
        chmod +x $BUILD_DIR/bin/*
        
        echo "构建环境准备完成"
    
    - name: 下载ROM文件
      run: |
        mkdir -p $ROM_DIR
        rom_path="$ROM_DIR/${{ steps.config.outputs.rom_name }}"
        filename="${{ steps.config.outputs.rom_name }}"
        
        echo "开始下载: $filename"
        echo "目标路径: $rom_path"
        
        download_progress() {
          local file="$1"
          local total_size="$2"
          local filename="$3"
          
          while true; do
            sleep 5
            if [ -f "$file" ]; then
              current_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
              if [ "$current_size" -gt 0 ]; then
                percent=$((current_size * 100 / total_size))
                echo "[$filename] 进度: $percent% - 已下载: $(numfmt --to=iec $current_size) / $(numfmt --to=iec $total_size)"
              fi
            fi
          done
        }
        
        echo "获取文件大小..."
        if command -v curl &> /dev/null; then
          file_size=$(curl -sI -L -k "${{ steps.config.outputs.rom_url }}" | grep -i 'content-length' | awk '{print $2}' | tr -d '\r' | tail -1)
        elif command -v wget &> /dev/null; then
          file_size=$(wget --spider -S "${{ steps.config.outputs.rom_url }}" 2>&1 | grep -i 'content-length' | awk '{print $2}' | tail -1)
        fi
        
        if [ -z "$file_size" ] || [ "$file_size" -lt 1000000 ]; then
          echo "::warning::无法获取文件大小，使用默认值1GB"
          file_size=1000000000
        fi
        
        echo "文件总大小: $(numfmt --to=iec $file_size)"
        
        download_progress "$rom_path" "$file_size" "$filename" &
        progress_pid=$!
        
        if command -v axel &> /dev/null; then
          echo "[$filename] 使用axel下载 (8线程)..."
          if axel -n 8 -U "Mozilla/5.0" -q -o "$rom_path" "${{ steps.config.outputs.rom_url }}"; then
            download_success=true
            echo "[$filename] axel下载完成"
          else
            echo "[$filename] axel下载失败，尝试其他方法"
          fi
        fi
        
        if [ ! -f "$rom_path" ] && command -v curl &> /dev/null; then
          echo "[$filename] 使用curl下载..."
          if curl -L -k -q -# -C - -o "$rom_path" "${{ steps.config.outputs.rom_url }}"; then
            download_success=true
            echo "[$filename] curl下载完成"
          else
            echo "[$filename] curl下载失败"
          fi
        fi
        
        if [ ! -f "$rom_path" ] && command -v wget &> /dev/null; then
          echo "[$filename] 使用wget下载..."
          if wget -q --show-progress -c -U "Mozilla/5.0" -O "$rom_path" "${{ steps.config.outputs.rom_url }}"; then
            download_success=true
            echo "[$filename] wget下载完成"
          else
            echo "[$filename] wget下载失败"
          fi
        fi
        
        kill $progress_pid >/dev/null 2>&1
        
        if [ ! -f "$rom_path" ]; then
          echo "::error::[$filename] 下载失败"
          exit 1
        fi
        
        downloaded_size=$(stat -c%s "$rom_path")
        if [ "$downloaded_size" -lt 1000000 ]; then
          echo "::error::[$filename] 文件过小 (${downloaded_size}字节)，可能下载失败"
          exit 1
        fi
        
        echo "[$filename] 下载成功! 大小: $(numfmt --to=iec $downloaded_size)"
    
    - name: 启用Super分区支持
      if: ${{ steps.config.outputs.make_super == 'true' }}
      run: |
        sed -i 's/SGSI.sh/dynamic_SGSI.sh/g' $BUILD_DIR/make.sh
        echo "已启用Super分区支持"
    
    - name: 配置系统构建脚本
      run: |
        if ${{ steps.config.outputs.make_miui == 'true' }}; then
          fix_script="MIUI.sh"
        elif ${{ steps.config.outputs.make_flyme == 'true' }}; then
          fix_script="Flyme.sh"
        elif ${{ steps.config.outputs.make_coloros == 'true' }}; then
          fix_script="ColorOS.sh"
        elif ${{ steps.config.outputs.make_h2os == 'true' }}; then
          fix_script="H2OS.sh"
        elif ${{ steps.config.outputs.make_smartisanos == 'true' }}; then
          fix_script="SmartisanOS.sh"
        elif ${{ steps.config.outputs.make_zui == 'true' }}; then
          fix_script="ZUI.sh"
        else
          fix_script=""
        fi

        if [ -n "$fix_script" ]; then
          echo "使用修复脚本: $fix_script"
          if [ ! -f "fix/$fix_script" ]; then
            echo "::error::修复脚本 fix/$fix_script 不存在!"
            exit 1
          fi
          
          rm -f $BUILD_DIR/fixbug/fixbug.sh
          cp "fix/$fix_script" $BUILD_DIR/fixbug/fixbug.sh
          chmod +x $BUILD_DIR/fixbug/fixbug.sh
          
          if [ "$fix_script" = "ColorOS.sh" ]; then
            echo "解密ColorOS ozip文件..."
            if ! python3 $BUILD_DIR/oppo_ozip/ozipdecrypt.py "$ROM_DIR/${{ steps.config.outputs.rom_name }}"; then
              echo "::error::ColorOS ozip解密失败"
              exit 1
            fi
            rm -f "$ROM_DIR/${{ steps.config.outputs.rom_name }}"
          fi
        else
          echo "使用默认构建配置"
        fi
        
    - name: 构建SGSI系统镜像
      timeout-minutes: 120
      run: |
        rm -f $BUILD_DIR/{SGSI.sh,makeimg.sh,dynamic_SGSI.sh,oppo.sh}
        cp make/* $BUILD_DIR/
        cp bin/* $BUILD_DIR/bin/
        
        find $BUILD_DIR -type f -exec grep -lZ 'chown' {} + | xargs -0 sed -i '/chown/d'
        find $BUILD_DIR -name "*.sh" -exec chmod +x {} \;
        chmod +x $BUILD_DIR/bin/*
        
        cd $BUILD_DIR
        mkdir -p out/{system,config}
        mkdir -p out/system/{bin,etc,lib,usr,framework,app,priv-app,vendor}
        
        echo '# 默认文件上下文' > out/config/system_file_contexts
        echo '/system(/.*)? u:object_r:system_file:s0' >> out/config/system_file_contexts
        echo '/vendor(/.*)? u:object_r:vendor_file:s0' >> out/config/system_file_contexts
        
        echo '# 默认文件系统配置' > out/config/system_fs_config
        echo '/system 0 0 755' >> out/config/system_fs_config
        echo '/vendor 0 0 755' >> out/config/system_fs_config
        
        echo "::group::构建日志"
        start_time=$(date +%s)
        if ! ./make.sh > build.log 2>&1; then
          echo "::error::构建过程失败"
          echo "最后50行日志:"
          tail -n 50 build.log
          exit 1
        fi
        build_output=$(cat build.log)
        echo "$build_output"
        end_time=$(date +%s)
        echo "构建耗时: $((end_time - start_time))秒"
        echo "::endgroup::"
        
        if [ ! -f "out/system.img" ]; then
          echo "::warning::system.img未生成，尝试手动创建"
          if [ ! -d "out/system" ]; then
            echo "::error::out/system目录不存在"
            exit 1
          fi
          
          system_size=$(du -sk out/system | cut -f1)
          img_size_kb=$((system_size * 135 / 100))
          img_size_mb=$(( (img_size_kb + 1023) / 1024 ))
          [ $img_size_mb -lt 1024 ] && img_size_mb=1024
          
          echo "创建 ${img_size_mb}MB 系统镜像 (原始大小: ${system_size}KB)"
          
          ./bin/make_ext4fs -T 1230768000 -S out/config/system_file_contexts \
            -C out/config/system_fs_config -l ${img_size_mb}M -a system out/system.img out/system/
            
          if [ ! -f "out/system.img" ]; then
            echo "::error::手动创建system.img失败"
            exit 1
          fi
        fi
        
        img_size=$(du -sh out/system.img | cut -f1)
        echo "生成的system.img大小: $img_size"
        mv out/system.img SGSI/
        cd ../../../
        
    - name: 压缩系统镜像
      id: compress
      run: |
        echo "::group::镜像压缩"
        img_path="$BUILD_DIR/SGSI/system.img"
        
        if [ ! -f "$img_path" ]; then
          echo "::error::系统镜像未找到: $img_path"
          exit 1
        fi
        
        orig_size=$(du -sh "$img_path" | awk '{print $1}')
        orig_size_bytes=$(stat -c%s "$img_path")
        
        echo "压缩系统镜像..."
        gzip -k -v "$img_path"
        
        if [ ! -f "$img_path.gz" ]; then
          echo "::error::压缩失败，未生成gz文件"
          exit 1
        fi
        
        compressed_size=$(du -sh "$img_path.gz" | awk '{print $1}')
        compressed_size_bytes=$(stat -c%s "$img_path.gz")
        
        actual_compression_ratio=$(echo "scale=2; 100 - ($compressed_size_bytes * 100 / $orig_size_bytes)" | bc)
        
        echo "压缩完成"
        echo "原始镜像大小: $orig_size ($(numfmt --to=iec $orig_size_bytes))"
        echo "压缩后大小:   $compressed_size ($(numfmt --to=iec $compressed_size_bytes))"
        echo "压缩率:       ${actual_compression_ratio}%"
        echo "::endgroup::"
        
        {
          echo "orig_size=$orig_size"
          echo "compressed_size=$compressed_size"
          echo "orig_size_bytes=$orig_size_bytes"
          echo "compressed_size_bytes=$compressed_size_bytes"
          echo "compression_ratio=$actual_compression_ratio"
        } >> $GITHUB_OUTPUT
        
    - name: 打包系统补丁
      run: |
        echo "打包系统补丁..."
        mkdir -p $BUILD_DIR/SGSI
        for i in {1..3}; do
          patch_dir="Patch/Patch$i"
          if [ -d "$patch_dir" ] && [ -n "$(ls -A "$patch_dir")" ]; then
            echo "打包补丁: Patch$i"
            zip_file="Patch$i.zip"
            if ! zip -r -0 "$zip_file" "$patch_dir"/*; then
              echo "::warning::补丁$i打包失败"
              continue
            fi
            mv "$zip_file" $BUILD_DIR/SGSI/
          fi
        done

    - name: 设置版本信息
      id: set_release_info
      run: |
        rom_name="${{ steps.config.outputs.rom_name }}"
        
        version=$(echo "$rom_name" | grep -oE '[Vv][0-9][0-9a-zA-Z.]*' | head -1 | sed 's/[Vv]//' || echo "unknown")
        
        base_name="${rom_name%.*}"
        release_name="${base_name} SGSI"
        release_tag="Android10-${base_name}-${{ github.run_number }}"
        
        echo "RELEASE_NAME=$release_name" >> $GITHUB_ENV
        echo "RELEASE_TAG=$release_tag" >> $GITHUB_ENV
        echo "ROM_VERSION=$version" >> $GITHUB_ENV
        
        echo "设置发布信息:"
        echo "名称: $release_name"
        echo "标签: $release_tag"
        echo "版本: $version"
        
    - name: 创建最终包
      id: create_pack
      run: |
        echo "::group::创建最终包"
        if [ ! -d "$BUILD_DIR/SGSI" ] || [ -z "$(ls -A "$BUILD_DIR/SGSI" 2>/dev/null)" ]; then
          echo "::error::没有找到可打包的内容"
          exit 1
        fi
        
        pack_name="${{ env.RELEASE_NAME }}.zip"
        echo "创建压缩包: $pack_name"
        
        if ! zip -r -0 -X "$pack_name" "$BUILD_DIR/SGSI"/*; then
          echo "::error::压缩包创建失败"
          exit 1
        fi
        
        if [ ! -f "$pack_name" ]; then
          echo "::error::压缩包未生成"
          exit 1
        fi
        
        file_size=$(du -sh "$pack_name" | cut -f1)
        file_size_bytes=$(stat -c%s "$pack_name")
        echo "压缩包创建成功! 大小: $file_size ($(numfmt --to=iec $file_size_bytes))"
        echo "::endgroup::"
        
        echo "pack_name=$pack_name" >> $GITHUB_OUTPUT
        
    - name: 准备上传文件
      run: |
        echo "::group::准备上传文件"
        pack_name="${{ steps.create_pack.outputs.pack_name }}"
        mkdir -p upload
        
        file_size_bytes=$(stat -c%s "$pack_name")
        max_size=1500000000
        
        echo "文件大小: $(numfmt --to=iec $file_size_bytes)"
        
        if [ $file_size_bytes -gt $max_size ]; then
          echo "文件过大，进行分割..."
          split_size=1400M
          
          split -b "$split_size" -d -a 3 "$pack_name" "upload/${pack_name%.zip}_part"
          
          echo "分割为 $(ls -1 upload | wc -l) 个文件"
        else
          echo "移动单个文件到上传目录"
          mv "$pack_name" upload/
        fi
        
        echo "上传文件列表:"
        ls -lh upload/
        echo "::endgroup::"
        
    - name: 清理工作区
      if: always()
      run: |
        echo "清理工作区..."
        rm -rf SGSI-build-tool/{10/tmp/*,out} || true
        rm -f *.tar *.log || true
        df -h
        
    - name: 发布SGSI版本
      if: success()
      uses: ncipollo/release-action@v1.8.6
      with:
        artifacts: 'upload/*'
        name: ${{ env.RELEASE_NAME }}
        tag: ${{ env.RELEASE_TAG }}
        token: ${{ secrets.GITHUB_TOKEN }}
        draft: false
        prerelease: false
        body: |
          SGSI构建成功!
          构建号: ${{ github.run_number }}
          原始ROM: ${{ steps.config.outputs.rom_name }}
          ROM版本: ${{ env.ROM_VERSION }}
          系统镜像大小:
          原始: ${{ steps.compress.outputs.orig_size }} (${{ steps.compress.outputs.orig_size_bytes }} 字节)
          压缩后: ${{ steps.compress.outputs.compressed_size }} (${{ steps.compress.outputs.compressed_size_bytes }} 字节)
          压缩率: ${{ steps.compress.outputs.compression_ratio }}%
          包含补丁: $(find Patch/ -maxdepth 1 -type d -name 'Patch*' -exec basename {} \; | tr '\n' ' ')
